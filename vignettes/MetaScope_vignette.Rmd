---
title: "Introduction to MetaScope"
author: 
- name: Aubrey Odom-Mabey
  affiliation: 
  - Program in Bioinformatics, Boston University, Boston, MA
  email: aodom@bu.edu
- name: Rahul Varki
  affiliation:
  - Research Assistant in Johnson Lab, Boston University School of Medicine, Boston, MA
  email: rvarki@bu.edu
- name: W. Evan Johnson
  affiliation:
  - The Section of Computational Biomedicine, Boston University School of Medicine, Boston, MA
  email: wej@bu.edu
date: '`r format(Sys.Date(), "%B %e, %Y")`'
package: MetaScope
output: 
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Introdution to MetaScope}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

# Important Note

Although it is not a requirement, MetaScope will fun faster and more efficiently for larger samples if the samtools package is present on your device. You can download it at <https://github.com/samtools/samtools>.

# Introduction

MetaScope is a complete metagenomics profiling package that can accurately identify the composition of microbes within a sample at a strain-level resolution. MetaScope can be considered as an updated and expanded R translation of [PathoScope 2.0](https://microbiomejournal.biomedcentral.com/articles/10.1186/2049-2618-2-33), a Python-based metagenomic profiling package created by the Johnson lab. A few improvements made in MetaScope include using the BAM file format instead of the SAM file format for significantly less disk space usage, removing all dependencies to NCBI's now defunct GI sequence annotations, and properly filtering reads that align to filter reference genomes. Functions to analyze host microbiome data are also planned to be added in future updates to the package.

The core functions within the package create a workflow that allows users to:

1.  Obtain reference genomes for target and filter microbes;
2.  Make aligner-specific indexes from genomes;
3.  Align reads to target genomes;
4.  Filter reads aligning to filter genomes;
5.  Reassign ambiguously mapped reads to their likely correct microbe of origin.

Due to the modular nature of the package, users can choose to either conduct all of their analysis or part of their analysis within the package. This is dependent on what data the user already has prior to using the package --- for example, if the user has already aligned their reads then they could skip functions (1), (2), and (3).

There are two types of workflows that are included in the package: the Rbowtie2 and the Rsubread workflow. The Rbowtie2 and Rsubread workflows are essentially analogous to each other, with the major difference being that functions (2), (3), and (4) differ by the aligner utilized. The Rbowtie2 functions utilize the [Bowtie2](https://www.nature.com/articles/nmeth.1923) aligner (Langmead 2012) whereas the [Rsubread](https://academic.oup.com/nar/article/47/8/e47/5345150) functions utilize the Rsubread aligner (Liao 2019). The nuances of how to use each function can be found by looking at each function's help manual (R command: `?<name of function>`). For reference, PathoScope2.0 uses the Bowtie2 aligner in its workflow.

In this vignette, we will analyze the mock data provided in the package via the Rbowtie2 workflow. We will utilize all the core functions in sequential order. We will make mention of the equivalent Rsubread function whenever an Rbowtie2 function is being used.

## Installation

In order to install MetaScope from GitHub, run the following code:

```{R, eval = FALSE}
if (!requireNamespace("devtools", quietly = TRUE))
  install.packages("devtools")
devtools::install_github("compbiomed/MetaScope")
```

```{R}
suppressPackageStartupMessages({
  library(MetaScope)
  library(magrittr)
})
NCBI_key <- "01d22876be34df5c28f4aedc479a2674c809"
options("ENTREZ_KEY" = NCBI_key)
```

# Data

The mock data provided in the package consists of simulated sequencing data generated from the `SAMtools` `wgsim` function (see `DATA_README.txt` in `inst/extdata` to see exact commands). The `wgsim` function is a tool which allows for the generation of FASTQ reads from a reference genome (FASTA). The mock data (`reads.fastq`) contains 1500 reads, of which 1000 reads are derived from the *Staphylococcus aureus* RF122 strain and 500 reads are derived from the *Staphylococcus epidermidis* RP62A strain. In this data set, we assume that the *S. aureus* RF122 reads are the reads of interest, and the *S. epidermidis* RP62A reads are known contaminant reads which should be removed during the analysis. Ideally, the microbial composition report (.csv) produced at the end of the analysis should contain only reads assigned to the *S. aureus* RF122 strain.

# Reference Genome Library

The MetaScope genome library workflow is designed to assist with collection of sequence data from the National Center for Biotechnology Information (NCBI) nucleotide database. Prior to doing so, the potential targets and filters for the analysis should be identified. That is, what "target" species do you expect to find in your metagenomic sample that you would like to identify, and what reads would you like to "filter" out from the data that are not essential to your analysis?

Typically, the targets of the analysis are microbes (that is, viruses, bacteria, and fungi), and we wish to filter out or discard any reads from the host in addition to artificially added sequences, such as Phi X 174. Following identification of the targets and filters, we use a reference genome library to align the vast number of sample reads back to the respective regions of origin in various species.

The `download_refseq()` function automatically extracts custom reference genome libraries in a FASTA file for microbial or host genomes. The user must first indicate a taxon for which to download the genomes, such as 'bacteria' or 'primates'. A table of possible entries can be viewed by accessing the `taxonomy_table` object. The user may then specify whether they wish to download only the RefSeq reference genomes, or both the reference and representative genomes. The compress option then allows users to specify whether to compress the output FASTA file; this is done by default.

## Downloading target genomes

Even though in this scenario we know exactly from where the reads in the mock data (`reads.fastq`) originate, in most cases we may only have a general idea of read origins. Therefore, in the following code, we will download the genome of the *Staphylococcus aureus* RF122 strain along with the genomes of a few other closely related *Staphylococcus aureus* strains from the NCBI RefSeq database. These genomes together will act as our target genome library.

```{R target lib, eval = TRUE, warning = FALSE, message = FALSE}
target_ref_temp <- tempfile()
dir.create(target_ref_temp)

all_species <- c("Staphylococcus aureus RF122",
                 "Staphylococcus aureus subsp. aureus ST398",
                 "Staphylococcus aureus subsp. aureus Mu3")
sapply(all_species, download_refseq, 
       reference = FALSE, representative = FALSE, compress = TRUE,
       out_dir = target_ref_temp, caching = TRUE)
```

## Downloading filter genomes

We will also download the genome of the *Staphylococcus epidermidis* RP62A strain from the NCBI nucleotide database, in an uncompressed FASTA format. This genome will act as our filter library.

```{R filter lib, warning = FALSE, message = FALSE}
filter_ref_temp <- tempfile()
dir.create(filter_ref_temp)

download_refseq(
  taxon = "Staphylococcus epidermidis RP62A",
  representative = FALSE, reference = FALSE,
  compress = TRUE, out_dir = filter_ref_temp,
  caching = TRUE)
```

# Demultiplex

Sequence runs on NGS instruments are typically carried out with multiple samples pooled together. An index tag (also called a barcode) consisting of a unique sequence of between 6 and 12bp is added to each sample so that the sequence reads from different samples can be identified. For 16s experiments or sequencing conducted using an Illumina machine, the process of demultiplexing (dividing your sequence reads into separate files for each index tag/sample) and generating the FASTQ data files required for downstream analysis can be done using the MetaScope demultiplexing workflow. This consists of the `demultiplex()` function, which takes as arguments a matrix of sample names/barcodes, a FASTQ file of barcodes by sequence header, and a FASTQ file of reads corresponding to the barcodes. Based on the barcodes given, the function extracts all reads for the indexed barcode and writes all the reads from that barcode to separate FASTQ files.

This is an optional step in the analysis process depending on whether your reads are multiplexed. The reads which we are currently trying to analyze are not multiplexed and therefore this step is skipped in our analysis. The example shown below is using different reads that are barcoded in order to show the utility of the function.

